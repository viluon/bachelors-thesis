% arara: xelatex
% arara: makeglossaries
% arara: xelatex
% arara: xelatex

% style inspired by
% https://github.com/omelkonian/presentations/blob/2c0b2e1f592a8f90797e4997c3ab8785b114f595/%5B2019.08.20%5D%20BitML%20(SRC%20Presentation%20@%20ICFP)/bitml-presentation.tex

\documentclass[aspectratio=169]{beamer}
\usetheme{metropolis}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, bm}
\usepackage{tcolorbox}
\usepackage[makeroom]{cancel}
\usepackage{mathpartir}
\usepackage{xparse,minted}

% figure support
\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

% style for tcolorboxes
\tcbset{plain/.style={colbacktitle=white,coltitle=black,colback=white}}
\pdfsuppresswarningpagegroup=1

% fonts
\usepackage{relsize}
\usepackage[tt=false]{libertine}
\usepackage[libertine]{newtxmath}

% colours
\definecolor{CTUBlue}{HTML}{007ac2}
\setbeamercolor{alerted text}{fg=CTUBlue}


\title{Haskell Dynamic Tracing}
\author{Ond≈ôej Kvapil}
\institute{Faculty of information technology, Czech technical university in Prague}
\date{28th April, 2021}


\begin{document}

\begin{center}
	\maketitle
\end{center}

\begin{frame}{Outline}
	\begin{itemize}
		\item Introduction
		\item Goals of the thesis
		\item Motivation behind the choice of topic
		\item Technical terminology and acronyms
		\item Current state of the solution
		\item Solution of the problem (expected outcome)
		\item Conclusion -- a summary of the important points, contributions
		\item Thanks \& discussion
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Introduction}
	\begin{itemize}
		\item<1-> Haskell is a \alert{lazy} language
		\item<2-> Delays evaluation of an expression until its value is needed
		\item<6-> Shares evaluated subexpressions
	\end{itemize}
	\begin{overprint}
		\onslide<3-5>
		\begin{minted}[autogobble]{haskell}
			snd :: (Int, Int) -> Int
			snd (x, y) = y
		\end{minted}
		\begin{overprint}
			\onslide<4>
			\begin{minted}[autogobble]{haskell}
				foo :: Int
				foo = snd (complexComputation, 3)
			\end{minted}
			\onslide<5>
			\begin{minted}[autogobble]{haskell}
				foo' :: Int
				foo' = snd (error "oops!", 3)
			\end{minted}
		\end{overprint}
		\onslide<7>
		\begin{minted}[autogobble]{haskell}
			let x = complexComputation
			in  f (x, x)
		\end{minted}
	\end{overprint}
\end{frame}

\begin{frame}{Goals}
	\begin{itemize}
		\item Key question: how is laziness used in practice? \pause
		\item Develop a \alert{dynamic tracing} framework \pause
		\item Tool capable of analysing real-world Haskell programs
	\end{itemize}
\end{frame}

\begin{frame}{Motivation}
	\begin{itemize}
		\item Interesting landscape -- Haskell is heavily used in academia
			\pause
		\item Lack of empirical results despite extensive theoretical study
			\pause
		\item Laziness has advantages as well as significant downsides
	\end{itemize}
\end{frame}

\begin{frame}{State-of-the-art}
	\begin{itemize}
		\item Unnecessary laziness leads to \alert{large memory overhead}
			\pause
		\item Some tools designed to avoid too much laziness
			(\texttt{nothunks}, \texttt{BangPatterns}) \pause
		\item Black-box problem: developers lack insight about the runtime
			state
	\end{itemize}
\end{frame}

\begin{frame}{Our solution}
	\begin{overprint}
		\onslide<1-3>
		\begin{itemize}
			\item<1-3> Compiler plugin for the \alert{Glasgow Haskell Compiler}
			\item<2-3> Transforms surface syntax of Haskell to add tracing calls
			\item<3> Traces evaluation of function calls and function arguments
		\end{itemize}
		\onslide<4>
		hi
	\end{overprint}
\end{frame}

\begin{frame}{Summary}
	\begin{itemize}
		\item Compile-time \alert{rewriting of programs} via a plugin for
			the Glasgow Haskell Compiler \pause
		\item Annotation with side-effecting tracing functions \pause
		\item Compiled program records a trace of relevant events alongside
			regular output
	\end{itemize}
\end{frame}

\begin{frame}{Thank you}
	Thanks!
\end{frame}

\end{document}
