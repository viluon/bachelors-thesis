% arara: xelatex
% arara: xelatex
% arara: xelatex


% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=B,english]{FITthesis}[2019/12/23]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% EDIT THIS
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Programming Research Laboratory}
\title{Haskell Dynamic Tracing}
\authorGN{Ondřej} %author's given name/names
\authorFN{Kvapil} %author's surname
\author{Ondřej Kvapil} %author's name without academic degrees
\authorWithDegrees{Ondřej Kvapil} %author's name with academic degrees
\supervisor{Ing. Filip Křikava, Ph.D.}
\acknowledgements{THANKS (remove entirely in case you do not wish to thank anyone)}
\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}
\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)
% \website{http://site.example/thesis} %optional thesis URL


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\setsecnumdepth{part}
\chapter{Introduction}
foo


\setsecnumdepth{all}
\chapter{State-of-the-art}
Although there are many practical functional languages in the ML family (F\#,
OCaml, SML), Haskell is the only non-strict language among them. Its most
popular compiler, the Glasgow Haskell Compiler (GHC), implements Haskell's
non-strict features by lazy evaluation facilitated mainly by a runtime data
structure called a \textit{thunk}, which represents delayed computations.

Although necessary for non-strictness as required by the Haskell spec [link],
laziness leads to many issues with runtime behaviour of Haskell programs.  The
accumulation of thunks at runtime is a frequent cause of pathological memory
behaviour and unpredictable performance. There is a number of libraries and
tools which aim to help the Haskell programmer inspect the runtime state of the
Haskell heap, force the evaluation of thunks known to be forced by the program
at a later point anyway, and avoid their creation altogether for certain
expressions.

Among the surveyed approaches to the inspection and management of thunks were
the following:
\begin{itemize}
	\item Hoed
	\item \texttt{nothunks}
	\item hat
	\item htrace
	\item \texttt{ghc-heap-view}
\end{itemize}

% TODO add newcommands for declarations, types, modules, and code
\section{Hoed}
Hoed\cite{gh-hoed} is a tracer and a debugger for Haskell. Unlike the built-in
debugger of GHCi, Hoed is implemented as a regular Haskell library. Users of
Hoed manually annotate functions of interest to make the tracer capture
relevant information during execution. The annotations are simply calls to the
provided debugging function \texttt{observe} with a signature similar to that
of the \texttt{trace} function from the \texttt{Debug.Trace} module of
Haskell's standard library, hiding unsafe IO. \texttt{observe} has type
\texttt{Observable a => Text -> a -> a}, its \texttt{Text} argument has to
equal the name of the function being annotated. The \texttt{Observable}
constraint on \texttt{a} is used by Hoed internally, the typeclass has a
default implementation. The resulting trace of the debugging session is exposed
via a web-based interface, to which the users connect with a regular web
browser.  Hoed's traces include information about which functions have been
called during the execution of the annotated program and what were their
arguments. It only collects information about annotated functions.

Hoed features several tools to help users analyse problems with their code and
find the culprits of test failures. One of these is \textit{algorithmic
debugging}, an interactive trace browser which uses an algorithm similar to
binary search to locate the deepest incorrect function in the recorded call
tree. It does so by asking the user questions about whether certain evaluations
were correct, working its way gradually deeper into the tree. The ``algorithmic
debugger'' ultimately reports the faults it located.

While Hoed's approach to debugging is certainly interesting and quite far
removed from the concept of debuggers in other languages, it lacks any kind of
awareness of the low-level details of non-strictness. This is perhaps due to
the fact that it was implemented at a time when it was generally believed that
competing implementations of Haskell will emerge. % TODO source
Hoed is thus intended for use with property testers like QuickCheck, % TODO link!
and not as a tool for the identification and resolution of language
implementation -dependent issues, such as memory leaks.


\section{\texttt{nothunks}}
\texttt{nothunks} is a recently released Haskell package which helps in writing
thunk-free code. It defines a new typeclass, \texttt{NoThunks}, along with
instances for common Haskell types. Any type with a \texttt{NoThunks} instance
can be inspected for unexpected thunks. The library also implements a number of
alternatives to common functions from the prelude. These reimplementations
check for unexpected thunks introduced during execution, throwing an exception
whenever a thunk is detected.

The exceptions of \texttt{nothunks} contain helpful information about the
context of the thunk which the library function detected, guiding the
programmer in locating the unexpectedly lazy code or data structure. The
library also allows various relaxations to the strictness of its inspection
policy, such as the \texttt{OnlyCheckWhnf} and \texttt{AllowThunk}
\texttt{newtype}s. Thanks to GHC Generics, % TODO link!
\texttt{nothunks} also offers the convenient \texttt{deriving (Generic,
NoThunks)} syntax to add instances of the necessary typeclasses for custom data
structures automatically.
% TODO mention that nothunks works wonders for dealing with memory leaks, but
%     is aimed primarily at avoiding thunks altogether, not at their close
%     inspection or something like strictness analysis.

% TODO do look into the mechanism by which nothunks actually checks for thunks,
%      however

\section{Hat}
The Haskell Tracer Hat\cite{proj-hat} is a source-level tracer. It works by
compiling Haskell source files to annotated -- but still textual -- Haskell
source files. After this source-to-source translation, the user compiles the
annotated source code and runs it to produce a Hat trace.

The trace is a rich recording which contains high-level information about each
reduction the program performed. Hat comes with a number of utilities for
exploring the trace files, including some forms of forward and backward
debugging, filtering utilities which show all arguments passed to top-level
functions, virtual stack traces, and even an interactive tool for locating
errors in a program, similar to one of the features of Hoed.

\begin{itemize}
	\item uhhh what is our analysis of Hat
	\item cool but has to deal with source-to-source which is a nuisance?
	\item compatibility with non-GHC compilers is not an important goal in
		today's Haskell climate?
\end{itemize}

% TODO so initially it was developed for the nhc compiler, gaining Haskell 98
% features and GHC support later on. The history of haskell paper
% https://dl.acm.org/doi/pdf/10.1145/1238844.1238856 has more info on this in
% section 10.4.2. Even in its prime time (?) it wasn't recognised as a useful
% tool, despite its many features.

The architectural decisions of Hat reflect the environment it originated in,
which unfortunately differs substantially from the current status quo. Its
source-to-source model of operation makes it compatible with various Haskell
compilers, 

oops what now % TODO

The Glasgow Haskell Compiler is the most widely used Haskell
compiler
% TODO citation needed
with many language extensions beyond Haskell 2010. In 2009, GHC became the
official compiler of the Haskell Platform\cite{haskell-platform}, further
cementing its monopoly as the primary implementation of the language.

Hat uses the \texttt{haskell-src-exts} package to parse the source language.

% TODO \texttt{haskell-src-exts} lacks feature parity with GHC
% TODO oblivious to laziness, implementation-agnostic

\section{htrace}
\texttt{htrace} % TODO link
is a simple package which exports a single function: \texttt{htrace :: String
-> a -> a}. As the name and function signature suggest, this function mirrors
the behaviour of the standard \texttt{trace}, except that when displaying the
tracing messages, \texttt{htrace} shows them hierarchically indented based on
the current call depth. It works simply by manipulating a global mutable
variable and hiding this fact from the user with \texttt{unsafePerformIO}.

Although very simple and oblivious to any laziness implementation details, this
approach is still useful for debugging purposes. The indented tracing messages
suggest the depth to which various thunks are evaluated at different points of
the program's operation.

\section{\texttt{ghc-heap-view}}
\texttt{ghc-heap-view} is a Haskell package which makes advanced introspection
of the Haskell heap a possibility from within pure Haskell code. It relies on
the \texttt{ghc-heap} library which comes bundled with GHC.

The library's notable high-level features include a function which attempts to
recreate readable Haskell source code from a runtime value, using \texttt{let}
bindings to express sharing. There are also tree and graph data structures for
heap mapping and a high-level algebraic data type for all Haskell closures,
complete with their info tables.

to-do:
\begin{itemize}
	\item explain trade-offs with those that need code changes (typeclass-based)
	\item explain problems with approaches independent of GHC
\end{itemize}

Despite Haskell users' considerable interest in avoiding the implicit delaying
of computations which the language is notorious for, there are no records of a
large-scale study of the use of laziness in practice akin to
\cite{emp-study-laziness-r}. The tool with a feature set closest to what is
necessary for a comprehensive analysis of the practical use of laziness is
likely \texttt{ghc-heap-view}, which allows the user to interactively inspect
the heap objects and look inside thunks using GHCi. However, the package
primarily provides a rich library interface. It does not implement a tracing
mode, which would facilitate collection of laziness-relevant information during
the execution of entire programs.

\chapter{Analysis and design}

\chapter{Realisation}

\setsecnumdepth{part}
\chapter{Conclusion}


\bibliography{bbl}
% TODO get ISO 690 working
\bibliographystyle{plain}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[GUI] Graphical user interface
	\item[XML] Extensible markup language
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
