% arara: xelatex
% arara: xelatex
% arara: xelatex


% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=B,english]{FITthesis}[2019/12/23]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation
\usepackage{xcolor}
\usepackage{blindtext}


% custom commands
\newcommand{\todo}[1]{\textcolor{red}{\textbf{[[#1]]}}}
\newcommand{\blind}[1][1]{\textcolor{gray}{\Blindtext[#1][1]}}
\newcommand{\citationNeeded}{\textcolor{red}{\textbf{[citation needed]}}}
\newcommand{\hackage}[1]{\texttt{#1}}
\newcommand{\hsSignature}[1]{\texttt{#1}}
\newcommand{\hsType}[1]{\texttt{#1}}
\newcommand{\hsIdent}[1]{\texttt{#1}}
\newcommand{\hsModule}[1]{\texttt{#1}}
\newcommand{\hsTC}[1]{\texttt{#1}}
\newcommand{\hsCode}[1]{\texttt{#1}}


% list of acronyms
\usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
\iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
\makeglossaries

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% EDIT THIS
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\department{Programming Research Laboratory}
\title{Haskell Dynamic Tracing}
\authorGN{Ondřej} %author's given name/names
\authorFN{Kvapil} %author's surname
\author{Ondřej Kvapil} %author's name without academic degrees
\authorWithDegrees{Ondřej Kvapil} %author's name with academic degrees
\supervisor{Ing. Filip Křikava, Ph.D.}
\acknowledgements{THANKS (remove entirely in case you do not wish to thank anyone)}
\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}
\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)
% \website{http://site.example/thesis} %optional thesis URL


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}
\newacronym{ghc}{GHC}{Glasgow Haskell Compiler}
\newacronym{ghci}{GHCi}{\acrshort{GHC} interpreter}
\newacronym{hpc}{HPC}{Haskell Program Coverage}
% TODO this should probs go into a glossary instead?
\newacronym{stg}{STG}{Spineless Tag\-less G-machine, an abstract machine based
on graph reduction\cite{stg-classic}. \acrshort{ghc} compiles the Core language
to STG instructions, machine code is generated from the STG representation.}
% TODO this as well (the acronyms should only list the unabbreviated form, not
% a description of what these are)
\newacronym{gnu}{GNU}{GNU's Not Unix, a Unix-like operating system}
\newacronym{hls}{HLS}{Haskell Language Server}
% TODO citation?
\newacronym{lsp}{LSP}{Language Server Protocol}


\setsecnumdepth{part}
\chapter{Introduction}
\blind[3]


\setsecnumdepth{all}
\chapter{State-of-the-art}
Although there are many practical functional languages in the ML family (F\#,
OCaml, SML), Haskell is the only non-strict language among them. Its most
popular compiler\citationNeeded, the \acrfull{ghc}, implements Haskell's
non-strict features by lazy evaluation facilitated mainly by a runtime data
structure called a \textit{thunk}, which represents delayed computations.

\todo{rewrite the following (repetitive use of ``although'', laziness is only
an implementation technique)}

Although necessary for non-strictness as required by the Haskell
spec\citationNeeded, laziness leads to many issues with runtime behaviour of
Haskell programs. The accumulation of thunks at runtime is a frequent cause of
pathological memory behaviour and unpredictable performance. There is a number
of libraries and tools which aim to help the Haskell programmer inspect the
runtime state of the Haskell heap, force the evaluation of thunks known to be
forced by the program at a later point anyway, and avoid their creation
altogether for certain expressions.

Among the surveyed approaches to the inspection and management of thunks were
the following:
\begin{itemize}
	\item Hoed
	\item \hackage{nothunks}
	\item Hat
	\item \hackage{htrace}
	\item \hackage{ghc-heap-view}
\end{itemize}

\section{Existing solutions for thunk management}
\blind[1]

\subsection{Hoed}
Hoed\cite{gh-hoed} is a tracer and a debugger for Haskell. Unlike the built-in
debugger of \acrshort{ghci}, Hoed is implemented as a regular Haskell library.
Users of Hoed manually annotate functions of interest to make the tracer
capture relevant information during execution. The annotations are simply calls
to the provided debugging function \hsIdent{observe} with a signature similar
to that of the \hsIdent{trace} function from the \hsModule{Debug.Trace} module
of Haskell's standard library, hiding unsafe IO. \hsIdent{observe} has type
\hsSignature{Observable a => Text -> a -> a}, its \hsType{Text} argument has to
equal the name of the function being annotated. The \hsType{Observable}
constraint on \hsType{a} is used by Hoed internally, the typeclass has a
default implementation. The resulting trace of the debugging session is exposed
via a web-based interface, to which the users connect with a regular web
browser.  Hoed's traces include information about which functions have been
called during the execution of the annotated program and what were their
arguments. It only collects information about annotated functions.

Hoed features several tools to help users analyse problems with their code and
find the culprits of test failures. One of these is \textit{algorithmic
debugging}, an interactive trace browser which uses an algorithm similar to
binary search to locate the deepest incorrect function in the recorded call
tree. It does so by asking the user questions about whether certain evaluations
were correct, working its way gradually deeper into the tree. The ``algorithmic
debugger'' ultimately reports the faults it located.

While Hoed's approach to debugging is certainly interesting and quite far
removed from the concept of debuggers in other languages, it lacks any kind of
awareness of the low-level details of non-strictness. This is perhaps due to
the fact that it was implemented at a time when it was generally believed that
competing implementations of Haskell will emerge\citationNeeded.  Hoed is thus
intended for use with property testers like QuickCheck\citationNeeded, and not
as a tool for the identification and resolution of language implementation
-dependent issues, such as memory leaks.


\subsection{\hackage{nothunks}}
\hackage{nothunks} is a recently released Haskell package which helps in writing
thunk-free code. It defines a new typeclass, \hsTC{NoThunks}, along with
instances for common Haskell types. Any type with a \hsTC{NoThunks} instance
can be inspected for unexpected thunks. The library also implements a number of
alternatives to common functions from the prelude. These re\-implementations
check for unexpected thunks introduced during execution, throwing an exception
whenever a thunk is detected.

The exceptions of \hackage{nothunks} contain helpful information about the
context of the thunk which the library function detected, guiding the
programmer in locating the unexpectedly lazy code or data structure. The
library also allows various relaxations to the strictness of its inspection
policy, such as the \hsType{OnlyCheckWhnf} and \hsType{AllowThunk}
\hsCode{newtype}s. Thanks to GHC Generics\citationNeeded, \hackage{nothunks}
also offers the convenient \hsCode{deriving (Generic, NoThunks)} syntax to add
instances of the necessary typeclasses for custom data structures
automatically.
% TODO mention that nothunks works wonders for dealing with memory leaks, but
%     is aimed primarily at avoiding thunks altogether, not at their close
%     inspection or something like strictness analysis.

% TODO do look into the mechanism by which nothunks actually checks for thunks,
%      however

\subsection{Hat}
The Haskell Tracer Hat\cite{proj-hat} is a source-level tracer. It works by
compiling Haskell source files to annotated -- but still textual -- Haskell
source files. After this source-to-source translation, the user compiles the
annotated source code and runs it to produce a Hat trace.

The trace is a rich recording which contains high-level information about each
reduction the program performed. Hat comes with a number of utilities for
exploring the trace files, including some forms of forward and backward
debugging, filtering utilities which show all arguments passed to top-level
functions, virtual stack traces, and even an interactive tool for locating
errors in a program, similar to one of the features of Hoed.

\todo{Rewrite comment into text, scratch the paragraphs below}
% TODO so initially it was developed for the nhc compiler, gaining Haskell 98
% features and GHC support later on. The history of haskell paper
% https://dl.acm.org/doi/pdf/10.1145/1238844.1238856 has more info on this in
% section 10.4.2. Even in its prime time (?) it wasn't recognised as a useful
% tool, despite its many features.

The architectural decisions of Hat reflect the environment it originated in,
which unfortunately differs substantially from the current status quo. Its
source-to-source model of operation makes it compatible with various Haskell
compilers,


The Glasgow Haskell Compiler is the most widely used Haskell compiler
\citationNeeded with many language extensions beyond Haskell 2010. In 2009,
\acrshort{ghc} became the official compiler of the Haskell
Platform\cite{haskell-platform}, further cementing its monopoly as the primary
implementation of the language.

Hat uses the \hackage{haskell-src-exts} package to parse the source language.

% TODO \texttt{haskell-src-exts} DOES NOT lack feature parity with GHC
% TODO oblivious to laziness, implementation-agnostic

\subsection{\hackage{htrace}}
\hackage{htrace} \citationNeeded is a simple package which exports a single
function: \hsSignature{htrace :: String -> a -> a}. As the name and function
signature suggest, this function mirrors the behaviour of the standard
\hsIdent{trace}, except that when displaying the tracing messages,
\hackage{htrace} shows them hierarchically indented based on the current call
depth. It works simply by manipulating a global mutable variable and hiding
this fact from the user with \hsIdent{unsafePerformIO}.

Although very simple and oblivious to any laziness implementation details, this
approach is still useful for debugging purposes. The indented tracing messages
suggest the depth to which various thunks are evaluated at different points of
the program's operation.

\subsection{\hackage{ghc-heap-view}}
\hackage{ghc-heap-view} is a Haskell package which makes advanced introspection
of the Haskell heap a possibility from within pure Haskell code. It relies on
the \hackage{ghc-heap} library which comes bundled with \acrshort{ghc}.

The library's notable high-level features include a function which attempts to
recreate readable Haskell source code from a runtime value, using \hsCode{let}
bindings to express sharing. There are also tree and graph data structures for
heap mapping and a high-level algebraic data type for all Haskell closures,
complete with their info tables.

\todo{To-do}:
\begin{itemize}
	\item explain trade-offs with those that need code changes (typeclass-based)
	\item explain problems with approaches independent of \acrshort{ghc}
\end{itemize}

Despite Haskell users' considerable interest in avoiding the implicit delaying
of computations which the language is notorious for, there are no records of a
large-scale study of the use of laziness in practice akin to
\cite{emp-study-laziness-r}. The tool with a feature set closest to what is
necessary for a comprehensive analysis of the practical use of laziness is
likely \hackage{ghc-heap-view}, which allows the user to interactively inspect
the heap objects and look inside thunks using \acrshort{ghci}. However, the
package primarily provides a rich library interface. It does not implement a
tracing mode, which would facilitate collection of laziness-relevant
information during the execution of entire programs.

\section{Existing profilers}
\blind[1]

\subsection{Haskell Program Coverage}
Haskell Program Coverage\cite{hpc-paper} is (unsurprisingly) a code coverage
tool for Haskell. Similarly to Hat, \acrshort{hpc} has a source-to-source mode
of operation but additionally offers tight integration with \acrshort{ghc} and
comes bundled with modern releases of the compiler. It supports all
\acrshort{ghc} language extensions.

\acrshort{hpc} allows easy instrumentation of arbitrarily complex Haskell
programs without source annotations. It wraps subexpressions in the program
with an unsafe side-effecting function which records its evaluation by mutating
a module-wide array of integer counters. The final state of the per-module
arrays forms the \acrshort{hpc} trace. This architecture is wired into the
\acrshort{ghc} compiler pipeline in all the major data structures (the surface
syntax, Core language, and \acrshort{stg}), which makes it both robust and
per\-for\-mant. The tool comes bundled with utilities for displaying the
original source code with colourful mark-up, highlighting interesting
subexpressions based on the information extracted from the trace. Notably,
\acrshort{hpc} supports traces of the boolean values of pattern guards, which
are added to the visualisation.

\acrshort{hpc}'s feature set can be of tremendous help to the Haskell
programmer, especially when combined with tools like
QuickCheck\cite{quickcheck-paper}. However, its traces are tuned specifically
for code coverage and do not contain enough information to be useful for any
kind of dynamic strictness analysis. While the \acrshort{hpc} traces are
sufficiently granular, the subexpression counters lack necessary information
about their execution context and timing.


\section{The Glasgow Haskell Compiler}
\todo{Explain that several previous approaches had a direct influence on the
compiler. \acrshort{ghc} now has \acrshort{hpc}-specific features, compiler plugins, which
supersede source-to-source transformations (strengthening the monopoly but
simplifying implementation and streamlining the process), and a codebase that's
increasingly amenable to various extensions via the trees that grow pattern,
\hsIdent{Tickish}, etc.}
\blind[1]

\subsection{Compiler plugins}
\blind[1]


\chapter{Analysis and design}
\todo{what is analysis?}
\blind[1]

Taking inspiration from \cite{emp-study-laziness-r}, the original
implementation plan was to work with \acrshort{ghci}. The bytecode compiler and
interpreter lack support for certain \acrshort{ghc} language extensions, namely
un\-box\-ed tuples and sums, but the supported subset of the language was
considered large enough to contain interesting examples. The relative
simplicity of the bytecode compilation pipeline and the fairly straightforward
evaluator were considered to provide a foundation amenable to low-level tweaks
deemed necessary for the extraction of crucial tracing information.

\blind[1]

The \acrshort{ghc} codebase is a large and complicated collection of source
files written in a number of programming languages, primarily Haskell and
C\cite{arch-ghc}. The ever-evolving project is supported by a custom build
system called Hadrian\citationNeeded, itself written in Haskell, which
bootstraps the self-hosting compiler in several steps. To build \acrshort{ghc},
an appropriate version of \acrshort{ghc} has to be installed already. The
installed compiler is referred to as the \textbf{stage 0} compiler \todo{fix
the formatting of stages}. Hadrian uses the \textbf{stage 0} compiler to build
first the Hadrian build system and with it the \textbf{stage 1} compiler, which
is a freshly built \acrshort{ghc} linked against the \textbf{stage 0}
\hackage{base} library. The \textbf{stage 1} compiler is subsequently used to
build the core libraries. It is then utilised again to build the \textbf{stage
2} compiler, which is linked against the freshly built \hackage{base}. The
\textbf{stage 2} compiler constitutes a complete build of \acrshort{ghc} from
source code. There is an optional follow-up step, where the \textbf{stage 2}
compiler builds a \textbf{stage 3} compiler, which is useful for profiling
\acrshort{ghc} while building \acrshort{ghc}.

The first step to working on the project after obtaining the source code is
setting up the build system. Since specific releases of \acrshort{ghc} require
specific \textbf{stage 0} compilers as the project quickly adapts to use new
language extensions, the management of \acrshort{ghc} versions on a Unix-like
system with a system-wide package manager can be difficult. To ease the
management of installed versions and enable quick switching between them, the
\texttt{ghcup} tool\cite{ghcup} has been developed. \todo{this will need some
more citations} \texttt{ghcup} lets the \acrshort{ghc} developer quickly
install and switch between the releases of not only \acrshort{ghc} itself, but
also Cabal, the Haskell build system and dependency manager, and the
\acrfull{hls}, an \acrshort{lsp}-compliant language server providing
Haskell-specific editor integration features.

There are several ways to build \acrshort{ghc}, as the compiler previously used
a build system based on \acrshort{gnu} Make (before switching to Hadrian) and
the old Make build system is still being phased out. Additionally, the build
tool of the programmer's choice can be combined with a Docker or Nix -assisted
set-up, simplifying the installation of other dependencies required for the
build process.

\todo{how do we say ``let's not pick Make tho?''}
\todo{ways and flavours!}
After the initial build, the \textbf{stage 1} compiler can be \textit{frozen}
by passing a flag to the build system on subsequent invocations. This prevents
rebuilding the \textbf{stage 1} compiler every time a source file change, which
speeds up the edit-compile-run cycle tremendously.

\blind[3]


\chapter{Realisation}
\blind[3]


\setsecnumdepth{part}
\chapter{Conclusion}

\blind[2]

\bibliography{bbl}
% TODO get ISO 690 working
\bibliographystyle{plain}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}

\todo{fix acronym glossary}
\printglossary[type=\acronymtype]


\chapter{Contents of enclosed CD}

\todo{figure out what to do about this}
%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
