@article{emp-study-laziness-r,
	author = {Goel, Aviral and Vitek, Jan},
	title = {On the Design, Implementation, and Use of Laziness in R},
	year = {2019},
	issue_date = {October 2019},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {3},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3360579},
	doi = {10.1145/3360579},
	abstract = {The R programming language has been lazy for over twenty-five years. This paper presents a review of the design and implementation of call-by-need in R, and a data-driven study of how generations of programmers have put laziness to use in their code. We analyze 16,707 packages and observe the creation of 270.9 B promises. Our data suggests that there is little supporting evidence to assert that programmers use laziness to avoid unnecessary computation or to operate over infinite data structures. For the most part R code appears to have been written without reliance on, and in many cases even knowledge of, delayed argument evaluation. The only significant exception is a small number of packages which leverage call-by-need for meta-programming.},
	journal = {Proc. ACM Program. Lang.},
	month = oct,
	articleno = {153},
	numpages = {27},
	keywords = {R language, delayed or lazy evaluation}
}

@ONLINE{gh-hoed,
	description = {Lighweight algorithmic debugging based on observing intermediate values.},
	title = {GitHub - MaartenFaddegon/Hoed: Hoed - A Lightweight Haskell Tracer and Debugger},
	url = {https://github.com/MaartenFaddegon/Hoed},
	urldate = {2021-03-14}
}

@ONLINE{proj-hat,
	title = {The Haskell Tracer Hat},
	url = {https://archives.haskell.org/projects.haskell.org/hat/},
	urldate = {2021-04-04}
}

@ONLINE{haskell-platform,
	description = {Haskell Platform is a Haskell distribution with batteries included},
	title = {Haskell Platform},
	url = {https://www.haskell.org/platform/},
	urldate = {2021-04-05}
}

@inproceedings{hpc-paper,
	title={Haskell program coverage},
	author={Gill, Andy and Runciman, Colin},
	booktitle={Proceedings of the ACM SIGPLAN workshop on Haskell workshop},
	pages={1--12},
	year={2007}
}

@article{quickcheck-paper,
	title={QuickCheck: a lightweight tool for random testing of Haskell programs},
	author={Claessen, Koen and Hughes, John},
	journal={Acm sigplan notices},
	volume={46},
	number={4},
	pages={53--64},
	year={2011},
	publisher={ACM New York, NY, USA}
}

@inproceedings{stg-classic,
	title={The spineless tagless G-machine},
	author={Peyton Jones, Simon L and Salkild, Jon},
	booktitle={Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	pages={184--201},
	year={1989}
}

@incollection{arch-ghc,
	chapter={The Glasgow Haskell Compiler},
	author={Marlow, Simon and Peyton Jones, Simon},
	crossref={arch-oss-apps},
}

@incollection{arch-ghc-design,
	chapter={Key Design Choices},
	crossref={arch-ghc},
}

@book{arch-oss-apps,
	booktitle={The Architecture of Open Source Applications: Structure, Scale, and a Few More Fearless Hacks},
	volume={II},
	date={May 2012},
	author={Brown, Amy and Wilson, Greg},
	journal={Online at http://aosabook.org}
}

@ONLINE{ghcup,
	description = {The Haskell (GHC) toolchain installer},
	keywords = {Haskell, Haskell programming language, ghc, ghcup},
	title = {ghcup - The Haskell (GHC) toolchain installer},
	url = {https://www.haskell.org/ghcup/},
	urldate = {2021-04-07}
}

@inproceedings{history-of-haskell,
	title={A history of Haskell: being lazy with class},
	author={Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	booktitle={Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	pages={12--1},
	year={2007}
}

@inproceedings{concurrent-haskell,
	title={Concurrent Haskell},
	author={Jones, Simon Peyton and Gordon, Andrew and Finne, Sigbjorn},
	booktitle={POPL},
	volume={96},
	pages={295--308},
	year={1996}
}

@inproceedings{ghc-source-plugins,
	title={Working with source plugins},
	author={Pickering, Matthew and Wu, Nicolas and N{\'e}meth, Boldizs{\'a}r},
	booktitle={Proceedings of the 12th ACM SIGPLAN International Symposium on Haskell},
	pages={85--97},
	year={2019}
}

@ONLINE{hkg-ghcplugins,
	title = {GhcPlugins},
	url = {http://hackage.haskell.org/package/ghc-8.10.2/docs/GhcPlugins.html},
	urldate = {2021-04-24}
}

@ONLINE{blog-source-plugins,
	title = {Source Plugins: Four ways to build a typechecked Haskell expression},
	author = {Pickering, Matthew},
	url = {https://mpickering.github.io/posts/2018-06-11-source-plugins.html},
	urldate = {2021-04-24}
}

@inproceedings{th-classic,
	author = {Sheard, Tim and Jones, Simon Peyton},
	title = {Template Meta-Programming for Haskell},
	year = {2002},
	isbn = {1581136056},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/581690.581691},
	doi = {10.1145/581690.581691},
	abstract = {We propose a new extension to the purely functional programming language Haskell that supports compile-time meta-programming. The purpose of the system is to support the algorithmic construction of programs at compile-time.The ability to generate code at compile time allows the programmer to implement such features as polytypic programs, macro-like expansion, user directed optimization (such as inlining), and the generation of supporting data structures and functions from existing data structures and functions.Our design is being implemented in the Glasgow Haskell Compiler, ghc.},
	booktitle = {Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell},
	pages = {1–16},
	numpages = {16},
	keywords = {meta programming, templates},
	location = {Pittsburgh, Pennsylvania},
	series = {Haskell '02}
}

@inproceedings{th-quasiquoting,
	author = {Mainland, Geoffrey},
	title = {Why It's Nice to Be Quoted: Quasiquoting for Haskell},
	year = {2007},
	isbn = {9781595936745},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1291201.1291211},
	doi = {10.1145/1291201.1291211},
	abstract = {Quasiquoting allows programmers to use domain specific syntax to construct program fragments. By providing concrete syntax for complex data types, programs become easier to read, easier to write, and easier to reason about and maintain. Haskell is an excellent host language for embedded domain specific languages, and quasiquoting ideally complements the language features that make Haskell perform so well in this area. Unfortunately, until now no Haskell compiler has provided support for quasiquoting. We present an implementation in GHC and demonstrate that by leveraging existing compiler capabilities, building a full quasiquoter requires little more work than writing a parser. Furthermore, we provide a compile-time guarantee that all quasiquoted data is type-correct.},
	booktitle = {Proceedings of the ACM SIGPLAN Workshop on Haskell Workshop},
	pages = {73–82},
	numpages = {10},
	keywords = {meta programming, quasiquoting},
	location = {Freiburg, Germany},
	series = {Haskell '07}
}

@article{syb-paper,
	title={Scrap your boilerplate: a practical design pattern for generic programming},
	author={L{\"a}mmel, Ralf and Jones, Simon Peyton},
	journal={ACM SIGPLAN Notices},
	volume={38},
	number={3},
	pages={26--37},
	year={2003},
	publisher={ACM New York, NY, USA}
}
